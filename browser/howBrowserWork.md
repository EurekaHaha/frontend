# 浏览器工作原理以及步骤

## 导航

### DNS查找

> DNS (Domain Name System)域名系统是管理IP与主机名之间关系的系统 **是应用层协议**  
> [详细](../net/dns.md)

查找步骤

1. 查找本地缓存
2. 查找本地HOST文件
3. 路由器缓存
4. 运营商缓存
5. DNS服务器

---

### TCP握手

当获取到服务器IP地址的时候，浏览器就会通过TCP的“三次握手”与服务器建立连接

> TCP三次握手：SYN,SYN-ACK,ACK

握手步骤

1. 开始握手前客户端处于closed状态,服务端处于listen状态
2. 开始握手，客户端向服务端发送一个SYN报文，并指明客户端的初始化序列号为ISN，SYN=1,seq=x，且客户端处于SYN_SEND状态。
3. 当服务端接收到客户端的SYN报文后，会用自己的SYN报文应答，并指定服务端的初始化序列号为ISN。同时会把客户端的ISN + 1作为ACK的值，表示自己已经受到客户端的SYN报文，SYN=1,seq=y,ACK=1,ack=x+1，此时服务端处于SYN_REVD状态。
4. 客户端收到服务端的SYN报文后会发送一个客户端的ACK报文同样把服务端的ISN+1作为ACK的值表示已经收到SYN报文, ACK=1,ack=y+1,seq=x+1，此时客户端处于ESTABLISHED状态。
5. 服务端端收到ACK报文后改变状态为ESTABLISHED，并开始传输数据。

> SYN=1的报文不能携带数据，且消耗掉一个序号  
> ACK的报文可以携带数据，不携带数据不需要消耗序号

---

### TLS协商

为了在HTTPS上建立安全连接需要使用TSL协商，它决定了什么密码用来加密通信。

> HTTPS会经过8次往返才能发出真正的请求  
> HTTPS是HTTP + SSL/TCP的简称  
> TLS是升级版的SSL，现在所使用的SSL基本都是TLS  
> 详细 [TLS](../net/tls.md)

步骤

1. 客户端发送client_hello
2. 服务端发送server_hello
3. 服务端发送证书
4. 客户端发送client_key(pre-master)
5. 服务端响应发送finish
6. 客户端响应发送finish

--- 

![详细信息](../imgs/ssl.jpg)

---

## 响应

建立了到web服务器的连接后，浏览器就会代表用户发送一个初始的HTTP GET请求，对于网站来说，这个请求通常是一个HTML文件。一旦服务器收到请求，它将使用相关的响应头和HTML的内容进行回复。

---

## 解析

[详细](./parsing&render.md)

### 构建DOM树

渲染关键路径第一步是处理HTML标记并构造DOM树

> 解析器发现一个非阻塞性资源时，浏览器会继续解析并请求这些资源，例如CSS或者图片。  
> 但是遇到没有async或者defer属性的script标签的时候，会阻塞渲染并停止HTML的解析。

*预加载扫描器*  

> 浏览器构建DOM树的时候，过程会占用主线程。当这种情况发生时，预加载扫描器将解析可用的内容并请求高优先级资源，如CSS,JavaScript和web字体。

*解析过程中的js与async和defer*  
> 发现js后，网页停止解析，将网页的渲染权交给javascript，javascript执行完毕后在交还给网页，继续解析并渲染网页  
> async异步加载，当async的脚本加载完毕后，浏览器将暂停解析，先执行async脚本  
> defer延迟加载，当网页解析完成后才会执行defer的脚本。

---

### 构建CSSOM树

第二步是处理CSS并构建成CSSOM树

> DOM和CSSOM是两棵树，是独立的数据结构。浏览器将CSS规则转换为可以理解和使用的样式映射。浏览器遍历CSS中的每个规则集，根据CSS选择器创建具有父子和兄弟的节点树。

---

## 渲染

### 样式计算

第三步是将DOM树和CSSOM树合成一个Render树，主线程(main thread)为每个DOM计算出真正样式。

> head,script,和具有样式 `display:none` 的节点 这些标签将不会出现在render树上

---

### 布局

第四步是在渲染树上运行布局，并计算每个节点的几何体的宽度高度和位置。  
> 布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程  
> 回流是对页面的任何部分或者整个文档的任何后续大小和位置的确定

---

### 绘制

知道每个对象的位置和大小之后需要判断绘制顺序。主线程(main thread)会对render tree进行遍历来获取绘制记录，绘制记录是对绘制过程的注释，即绘制顺序


> 为了确保平滑滚动和动画，占据主线程的所有内容，包括计算样式、以及回流重绘必须让浏览器在16.67ms内完成。  
> 为了确保重绘的速度比初始绘制速度更快，屏幕上的绘图通常被分解为数层，如果绘图被分解为数层，则需要合成。  
> 绘制将render树中的元素分解为多个层，将内容提升到GPU上的层(而不是CPU上的主线程)。  
> 层可以提高性能，但是是以内存管理为代价的。

---

### 合成

即将多层融合

---

## 交互

[详见](./event.md)